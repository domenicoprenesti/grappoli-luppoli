<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris 3D ‚Äî Rotazioni X/Y/Z</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b1020;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #hud{
      position:fixed;left:12px;top:12px;color:#fff;
      background:rgba(0,0,0,.45);padding:10px 12px;border-radius:10px;
      user-select:none;line-height:1.25;min-width:250px;
    }
    #hud b{font-size:16px}
    #help{
      position:fixed;right:12px;top:12px;color:#fff;
      background:rgba(0,0,0,.45);padding:10px 12px;border-radius:10px;
      user-select:none;text-align:right;
    }
    #msg{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      color:#fff;text-align:center;pointer-events:none;
      font-size:22px;text-shadow:0 2px 18px rgba(0,0,0,.8);
      padding:24px;
    }
    canvas{display:block}
  </style>
</head>
<body>
  <div id="hud">
    <b>Tetris 3D</b><br/>
    Punteggio: <span id="score">0</span><br/>
    Layer: <span id="lines">0</span><br/>
    Livello: <span id="level">1</span>
  </div>
  <div id="help">
    ‚Üê ‚Üí : X<br/>
    ‚Üë ‚Üì : Z<br/>
    Z/X : rot Y<br/>
    A/S : rot X<br/>
    Q/E : rot Z<br/>
    Spazio: drop<br/>
    Shift: soft<br/>
    R: restart
  </div>
  <div id="msg"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

/* -----------------------------
   Config pozzo (well)
----------------------------- */
const W = 5;          // X
const D = 5;          // Z
const H = 18;         // Y (altezza)
const CELL = 1.0;

const BASE_FALL = 0.65;       // sec per step al livello 1
const SOFT_MULT = 0.10;       // soft drop = 10% del tempo
const LEVEL_EVERY = 6;        // layer completi per livello

/* -----------------------------
   Scene
----------------------------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0b1020, 12, 60);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
camera.position.set(9, 14, 14);
camera.lookAt(0, 7, 0);

scene.add(new THREE.HemisphereLight(0xffffff, 0x1c2a3a, 0.95));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(10, 25, 10);
scene.add(dir);

/* -----------------------------
   HUD
----------------------------- */
const elScore = document.querySelector("#score");
const elLines = document.querySelector("#lines");
const elLevel = document.querySelector("#level");
const elMsg = document.querySelector("#msg");
const showMsg = (t="") => elMsg.innerHTML = t;

/* -----------------------------
   Helpers coordinate
   Grid coords: x in [0..W-1], z in [0..D-1], y in [0..H-1]
   y=0 √® il "pavimento"
----------------------------- */
function inBounds(x,y,z){
  return x>=0 && x<W && z>=0 && z<D && y>=0 && y<H;
}
function key(x,y,z){ return `${x},${y},${z}`; }

// Convert grid to world position (centered)
function gridToWorld(x,y,z){
  const wx = (x - (W-1)/2) * CELL;
  const wy = y * CELL;
  const wz = (z - (D-1)/2) * CELL;
  return new THREE.Vector3(wx, wy, wz);
}

/* -----------------------------
   Well visuals (wireframe box)
----------------------------- */
const well = new THREE.Group();
{
  const box = new THREE.BoxGeometry(W*CELL+0.02, H*CELL+0.02, D*CELL+0.02);
  const edges = new THREE.EdgesGeometry(box);
  const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x6b77a8 }));
  line.position.y = (H*CELL)/2 - 0.5*CELL;
  well.add(line);

  // pavimento
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(W*CELL, D*CELL),
    new THREE.MeshStandardMaterial({ color: 0x3b3f46, roughness: 0.95 })
  );
  floor.rotation.x = -Math.PI/2;
  floor.position.y = -0.5*CELL;
  well.add(floor);
}
scene.add(well);

/* -----------------------------
   Board state: occupied cells
----------------------------- */
const board = new Map(); // key -> {mesh, color}

/* -----------------------------
   Tetromini (2D) come set di 4 cubi
   (li ruotiamo in 3D: diventano "policubi" orientabili)
   Coordinate locali attorno all'origine.
----------------------------- */
const SHAPES = [
  // I
  { name:"I", blocks:[[ -1,0,0],[0,0,0],[1,0,0],[2,0,0]] },
  // O
  { name:"O", blocks:[[0,0,0],[1,0,0],[0,0,1],[1,0,1]] },
  // T
  { name:"T", blocks:[[-1,0,0],[0,0,0],[1,0,0],[0,0,1]] },
  // L
  { name:"L", blocks:[[-1,0,0],[0,0,0],[1,0,0],[1,0,1]] },
  // J
  { name:"J", blocks:[[-1,0,1],[-1,0,0],[0,0,0],[1,0,0]] },
  // S
  { name:"S", blocks:[[-1,0,1],[0,0,1],[0,0,0],[1,0,0]] },
  // Z
  { name:"Z", blocks:[[-1,0,0],[0,0,0],[0,0,1],[1,0,1]] },
];

/* -----------------------------
   Rotazioni a 90¬∞ su assi X/Y/Z
   Applichiamo su blocchi locali (integri) usando trasformazioni discrete.
----------------------------- */
function rotX([x,y,z]){ return [ x, -z,  y]; } // +90¬∞ attorno X
function rotY([x,y,z]){ return [ z,  y, -x]; } // +90¬∞ attorno Y
function rotZ([x,y,z]){ return [-y,  x,  z]; } // +90¬∞ attorno Z

function applyRot(blocks, axis, times){
  let out = blocks.map(b=>[...b]);
  const t = ((times%4)+4)%4;
  for(let i=0;i<t;i++){
    out = out.map(b => axis==="x" ? rotX(b) : axis==="y" ? rotY(b) : rotZ(b));
  }
  return out;
}

// Normalizza per evitare "offset strani": sposta i blocchi in modo che min x/z/y = 0 o vicino
function normalize(blocks){
  let minX=Infinity,minY=Infinity,minZ=Infinity;
  for(const [x,y,z] of blocks){
    minX=Math.min(minX,x); minY=Math.min(minY,y); minZ=Math.min(minZ,z);
  }
  // per tetris 3D √® comodo NON forzare minY=0 sempre (ruotando pu√≤ diventare verticale),
  // ma ci serve un anchor stabile. Portiamo min a valori vicini a 0.
  return blocks.map(([x,y,z]) => [x-minX, y-minY, z-minZ]);
}

/* -----------------------------
   Piece (attiva)
----------------------------- */
const cubeGeo = new THREE.BoxGeometry(CELL, CELL, CELL);
function makeMat(hex){
  return new THREE.MeshStandardMaterial({ color: hex, roughness: 0.65, metalness: 0.05 });
}
const COLORS = [0xffd700,0x7cf0ff,0xff6b6b,0x7bff7b,0xb37bff,0xffa34d,0x4da3ff];

let active = null; // {shapeIndex, blocksLocal, pos:{x,y,z}, group, color}
let score = 0;
let cleared = 0;
let level = 1;
let gameOver = false;

function fallInterval(){
  // aumenta velocit√† col livello (limite)
  return Math.max(0.12, BASE_FALL * Math.pow(0.88, level-1));
}

function spawnPiece(){
  const idx = Math.floor(Math.random()*SHAPES.length);
  const color = COLORS[Math.floor(Math.random()*COLORS.length)];
  const base = SHAPES[idx].blocks;

  // inizialmente normalizziamo sul piano, poi spawniamo alto al centro
  let blocks = normalize(base);

  const group = new THREE.Group();
  const mat = makeMat(color);
  for(let i=0;i<4;i++){
    const m = new THREE.Mesh(cubeGeo, mat);
    group.add(m);
  }
  scene.add(group);

  // spawn center
  const pos = {
    x: Math.floor((W-2)/2),
    z: Math.floor((D-2)/2),
    y: H-1
  };

  active = { shapeIndex: idx, blocksLocal: blocks, pos, group, color };

  // se collide subito -> game over
  if(!canPlace(active.pos, active.blocksLocal)){
    endGame();
    return;
  }
  syncActiveMeshes();
}

function syncActiveMeshes(){
  if(!active) return;
  const {blocksLocal, pos, group} = active;
  for(let i=0;i<4;i++){
    const [bx,by,bz] = blocksLocal[i];
    const gx = pos.x + bx;
    const gy = pos.y + by;
    const gz = pos.z + bz;
    group.children[i].position.copy(gridToWorld(gx,gy,gz));
  }
}

function canPlace(pos, blocksLocal){
  for(const [bx,by,bz] of blocksLocal){
    const x = pos.x + bx;
    const y = pos.y + by;
    const z = pos.z + bz;
    if(!inBounds(x,y,z)) return false;
    if(board.has(key(x,y,z))) return false;
  }
  return true;
}

/* -----------------------------
   Lock / Clear layers
----------------------------- */
function lockPiece(){
  if(!active) return;
  const {blocksLocal, pos, group, color} = active;

  // trasferisci cubi nel board (nuovi mesh per semplicit√†)
  const mat = makeMat(color);
  for(const [bx,by,bz] of blocksLocal){
    const x = pos.x + bx;
    const y = pos.y + by;
    const z = pos.z + bz;
    const m = new THREE.Mesh(cubeGeo, mat);
    m.position.copy(gridToWorld(x,y,z));
    scene.add(m);
    board.set(key(x,y,z), { mesh: m, color });
  }

  // rimuovi gruppo attivo
  scene.remove(group);
  active = null;

  // clear layer completi
  const clearedNow = clearFullLayers();
  if(clearedNow>0){
    cleared += clearedNow;
    // scoring base (stile tetris, ma in 3D layer)
    const layerScore = [0, 100, 250, 450, 700][Math.min(4, clearedNow)];
    score += layerScore * level;
    // level up
    level = 1 + Math.floor(cleared / LEVEL_EVERY);
  }

  // spawn next
  spawnPiece();
  updateHUD();
}

function clearFullLayers(){
  let clearedCount = 0;

  // per ogni y, verifica se tutte le celle (W*D) sono occupate
  for(let y=0;y<H;y++){
    let full = true;
    for(let x=0;x<W && full;x++){
      for(let z=0;z<D;z++){
        if(!board.has(key(x,y,z))){ full=false; break; }
      }
    }
    if(full){
      clearedCount++;
      // rimuovi layer y
      for(let x=0;x<W;x++){
        for(let z=0;z<D;z++){
          const k = key(x,y,z);
          const cell = board.get(k);
          if(cell){
            scene.remove(cell.mesh);
            board.delete(k);
          }
        }
      }
      // fai scendere tutto sopra y di 1
      // (ripeti per lo stesso y perch√© si √® creato un "vuoto" l√¨)
      for(let yy=y+1; yy<H; yy++){
        for(let x=0;x<W;x++){
          for(let z=0;z<D;z++){
            const fromK = key(x,yy,z);
            const cell = board.get(fromK);
            if(cell){
              board.delete(fromK);
              const toK = key(x,yy-1,z);
              board.set(toK, cell);
              cell.mesh.position.copy(gridToWorld(x,yy-1,z));
            }
          }
        }
      }
      // dopo aver fatto shift down, rianalizza lo stesso y
      y--;
    }
  }
  return clearedCount;
}

/* -----------------------------
   Moves / Rotations
----------------------------- */
function tryMove(dx,dy,dz){
  if(!active || gameOver) return;
  const newPos = { x: active.pos.x + dx, y: active.pos.y + dy, z: active.pos.z + dz };
  if(canPlace(newPos, active.blocksLocal)){
    active.pos = newPos;
    syncActiveMeshes();
  } else if(dy < 0 && dx===0 && dz===0){
    // se tenti di scendere e non puoi -> lock
    lockPiece();
  }
}

function tryRotate(axis, dir){ // dir = +1 o -1 (90¬∞)
  if(!active || gameOver) return;

  // Ruota i blocchi attivi intorno all'asse, con "kick" semplice
  let rotated = active.blocksLocal.map(b=>[...b]);
  rotated = applyRot(rotated, axis, dir>0 ? 1 : 3);

  // per mantenere numeri piccoli e consistenti
  rotated = normalize(rotated);

  const kicks = [
    {x:0,y:0,z:0},
    {x:1,y:0,z:0},{x:-1,y:0,z:0},
    {x:0,y:0,z:1},{x:0,y:0,z:-1},
    {x:1,y:0,z:1},{x:-1,y:0,z:-1},
    {x:0,y:1,z:0}, // kick verso l'alto se serve (rare)
  ];

  for(const k of kicks){
    const testPos = { x: active.pos.x + k.x, y: active.pos.y + k.y, z: active.pos.z + k.z };
    if(canPlace(testPos, rotated)){
      active.blocksLocal = rotated;
      active.pos = testPos;
      syncActiveMeshes();
      return;
    }
  }
}

/* -----------------------------
   Drop
----------------------------- */
function hardDrop(){
  if(!active || gameOver) return;
  let steps = 0;
  while(true){
    const newPos = { x: active.pos.x, y: active.pos.y - 1, z: active.pos.z };
    if(canPlace(newPos, active.blocksLocal)){
      active.pos = newPos;
      steps++;
    } else {
      // bonus drop
      score += steps * 2;
      syncActiveMeshes();
      lockPiece();
      updateHUD();
      return;
    }
  }
}

/* -----------------------------
   Input
----------------------------- */
const keys = {
  left:false,right:false,up:false,down:false,
  soft:false
};

addEventListener("keydown", (e)=>{
  if(e.repeat) return;
  if(e.key==="ArrowLeft") keys.left = true;
  if(e.key==="ArrowRight") keys.right = true;
  if(e.key==="ArrowUp") keys.up = true;
  if(e.key==="ArrowDown") keys.down = true;
  if(e.key==="Shift") keys.soft = true;

  if(e.key===" "){ e.preventDefault(); hardDrop(); }
  if(e.key.toLowerCase()==="r"){ reset(); }

  // rotazioni
  if(e.key.toLowerCase()==="z") tryRotate("y", +1);
  if(e.key.toLowerCase()==="x") tryRotate("y", -1);
  if(e.key.toLowerCase()==="a") tryRotate("x", +1);
  if(e.key.toLowerCase()==="s") tryRotate("x", -1);
  if(e.key.toLowerCase()==="q") tryRotate("z", +1);
  if(e.key.toLowerCase()==="e") tryRotate("z", -1);
});

addEventListener("keyup", (e)=>{
  if(e.key==="ArrowLeft") keys.left = false;
  if(e.key==="ArrowRight") keys.right = false;
  if(e.key==="ArrowUp") keys.up = false;
  if(e.key==="ArrowDown") keys.down = false;
  if(e.key==="Shift") keys.soft = false;
});

addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* -----------------------------
   Game loop
----------------------------- */
let accum = 0;
let fall = fallInterval();
const clock = new THREE.Clock();

function updateHUD(){
  elScore.textContent = String(score);
  elLines.textContent = String(cleared);
  elLevel.textContent = String(level);
}

function endGame(){
  gameOver = true;
  showMsg(`üí• Game Over<br/>Punteggio: <b>${score}</b><br/>Premi <b>R</b> per ricominciare`);
}

function reset(){
  // remove all board meshes
  for(const {mesh} of board.values()) scene.remove(mesh);
  board.clear();

  // remove active
  if(active){
    scene.remove(active.group);
    active = null;
  }

  score = 0;
  cleared = 0;
  level = 1;
  gameOver = false;
  updateHUD();
  showMsg("");

  spawnPiece();
  accum = 0;
}

function step(dt){
  if(gameOver) return;

  // input continuo (move a rate-limit)
  // piccola "repeat" manuale
  moveRepeat(dt);

  // gravit√†
  fall = fallInterval() * (keys.soft ? SOFT_MULT : 1);
  accum += dt;
  if(accum >= fall){
    accum = 0;
    tryMove(0,-1,0);
  }
}

let moveTimer = 0;
function moveRepeat(dt){
  moveTimer += dt;
  const rate = 0.09;
  if(moveTimer < rate) return;
  moveTimer = 0;

  if(keys.left)  tryMove(-1,0,0);
  if(keys.right) tryMove(+1,0,0);
  if(keys.up)    tryMove(0,0,-1);
  if(keys.down)  tryMove(0,0,+1);
}

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.033, clock.getDelta());

  // leggera orbit camera ‚Äúfissa‚Äù
  // (se vuoi, poi la rendiamo ruotabile col mouse)
  step(dt);

  // ‚Äúshimmer‚Äù sul pozzo
  renderer.render(scene, camera);
}

/* -----------------------------
   Start
----------------------------- */
showMsg("Ruota i pezzi su X/Y/Z e chiudi layer completi!<br/>Premi un tasto per iniziare.");
setTimeout(()=>showMsg(""), 1800);
reset();
animate();

</script>
</body>
</html>
